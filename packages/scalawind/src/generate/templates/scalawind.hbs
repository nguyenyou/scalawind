package {{packageName}}

import scala.quoted.*
import scala.annotation.unused

case class TW() {
  {{#each modifiers}}
  def {{this.name}}(@unused styles: TW): TW = TW()
  {{/each}}
  def important(@unused styles: TW): TW = TW()
  def i(@unused styles: TW): TW = TW()
  def raw(@unused classString: String): TW = TW()
  def variant(selector: String, styles: TW): TW = TW()
  def opacity(value: Int): TW = TW()
  def o(value: Int): TW = TW()
}

object tw:
  def apply(): TW = TW()
  {{#each standard}}
  {{this.doc}}
  def {{this.prop}}: TW = TW()
  {{/each}}
  {{#each arbitrary}}
  def {{this.methodName}}(value: String): TW = TW()
  {{/each}}
  {{#each modifiers}}
  def {{this.name}}(@unused styles: TW): TW = TW()
  {{/each}}
  def important(@unused styles: TW): TW = TW()
  def i(@unused styles: TW): TW = TW()
  def raw(@unused classString: String): TW = TW()
  def variant(selector: String, styles: TW): TW = TW()

extension (tailwind: TW)
  {{#each standard}}
  {{this.doc}}
  def {{this.prop}}: TW = TW()
  {{/each}}
  {{#each arbitrary}}
  def {{this.methodName}}(value: String): TW = TW()
  {{/each}}

inline def sw(inline tailwind: TW): String =
  ${ swImpl('tailwind) }

def swImpl(tailwindExpr: Expr[TW])(using Quotes): Expr[String] =
  import quotes.reflect.*

  def fmtToTW(rawName: String) =
    rawName.replace("_", "-").replace("$", "/").replace("dot", ".")

  def extractClassNames(term: Term, prefix: String = "", important: Boolean = false): List[String] = {
    var stack = List((term, prefix, important))
    var classNames = List.empty[String]

    while (stack.nonEmpty) {
      val (currentTerm, currentPrefix, currentImportant) = stack.head
      stack = stack.tail

      currentTerm match {
        case Apply(Select(inner, "important"), List(styles)) =>
          stack = (styles, currentPrefix, true) :: stack
          stack = (inner, currentPrefix, currentImportant) :: stack
        case Apply(Select(inner, "opacity"), List(Literal(IntConstant(value)))) =>
          val classes = extractClassNames(inner, currentPrefix, currentImportant)
          if (classes.isEmpty) report.errorAndAbort("Opacity applied without preceding class.")
          classNames = classNames ++ classes.init :+ s"${classes.last}/$value"
        case Inlined(_, _, inner) =>
          stack = (inner, currentPrefix, currentImportant) :: stack
        case Select(inner, name) =>
          val methodName = fmtToTW(name)
          val className = s"$currentPrefix${if (currentImportant) "!" else ""}${methodName}"
          classNames = classNames :+ className
          stack = (inner, currentPrefix, currentImportant) :: stack
        case Ident("tw") =>
        // No action needed, just continue processing the remaining stack
        case Apply(Ident(name), List(arg)) =>
          val methodName = fmtToTW(name)
          val className = s"$currentPrefix${if (currentImportant) "!" else ""}${methodName}"
          classNames = classNames :+ className
          stack = (arg, currentPrefix, currentImportant) :: stack
        case Apply(Select(inner, name), List(Literal(StringConstant(value)))) if name == "raw" =>
          val className = s"$currentPrefix${if (currentImportant) "!" else ""}$value"
          classNames = classNames :+ className
          stack = (inner, currentPrefix, currentImportant) :: stack
        case Apply(Select(inner, name), List(Literal(StringConstant(value)))) =>
          val methodName = fmtToTW(name)
          val className = s"$currentPrefix${if (currentImportant) "!" else ""}${methodName}[$value]"
          classNames = classNames :+ className
          stack = (inner, currentPrefix, currentImportant) :: stack
        case Apply(Apply(Ident(name), args), List(Literal(StringConstant(value)))) =>
          val methodName = fmtToTW(name)
          val className = s"$currentPrefix${if (currentImportant) "!" else ""}${methodName}[$value]"
          classNames = classNames :+ className
          stack = args.map(arg => (arg, currentPrefix, currentImportant)) ++ stack
        case Apply(Select(Ident("tw"), name), List(inner)) =>
          val methodName = fmtToTW(name)
          stack = (inner, s"$currentPrefix${methodName}:", currentImportant) :: stack
        case Apply(Select(inner, "variant"), List(Literal(StringConstant(selector)), styles)) =>
          val variantPrefix = s"$currentPrefix[$selector]:" // Use the selector as provided
          val styleClasses = extractClassNames(styles, variantPrefix, currentImportant) // Extract classes with the variant prefix
          classNames = classNames ++ styleClasses
          stack = (inner, currentPrefix, currentImportant) :: stack
        case Apply(Select(inner, name), args) =>
          val methodName = fmtToTW(name)
          val innerClasses = args.flatMap(arg => extractClassNames(arg, s"$currentPrefix${methodName}:"))
          classNames = classNames ++ innerClasses
          stack = (inner, currentPrefix, currentImportant) :: stack
        case unexpectedTerm =>
          report.errorAndAbort(s"Unexpected term: $unexpectedTerm")
      }
    }
    classNames
  }

  val term = tailwindExpr.asTerm
  val classNames = extractClassNames(term)
  val combinedClasses = classNames.reverse.mkString(" ")
  {{#if previewCompliedResult}}
  report.info(s"$combinedClasses")
  {{/if}}
  Expr(combinedClasses)
